---
title: 'Написание функций'
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
    highlight: pygments
  # df_print: paged
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Мы с вами уже знакомы с функциями в _R_. Например, когда использовали функцию `print()` или `sum()`. Мы также знаем, что функция работает следующим образом: она берет что-то на вход, потом с этим что-то делает (мы называем это "черный ящик") и в конце что-то выводит. Например функция `sum()` может брать массив из чисел и выводить их сумму. Но как она это делает? Что происходит в "черном ящике"? На эти вопросы мы и ответим с вами в этом разделе, а также научимся писать свои собственные функции. 

## Зачем нужны функции и способы их задания

Предположим перед нами стоит задача высчитать 3!, 5!, 0!. Как бы мы это сделали, зная все, что уже прошли?

```{r}
# 3!
otv = 1
for(i in 1:3){
  otv <- otv * i
}
print(otv)

# 5!
otv2 = 1
for(i in 1:5){
  otv2 <- otv2 * i 
}
print(otv2)

# 0! - это 1
print(1)
```

Уже можно заметить, что код занимает много места, да и глупо каждый раз писать заново практически одно и то же. Если же задача была сложнее, то проблем возникло бы больше. 

Для таких ситуаций существуют функции. Функции — это такие участки кода, которые изолированы от остальный программы и выполняются только тогда, когда вызываются. Функция задается следующим образом

```{r}
# эта часть кода не будет выполняться
fact <- function(x){
  res <- 1
  for(i in 1:x){
    if(x == 0){
      return(res)
      }
    res <- res * i
  }
  return(res)
}

# теперь вызываем функцию
fact(0)
fact(1)
fact(2)
fact(3)
fact(5)
```

Видно, что код довольно упростился. 

Теперь поговорим о нескольких замечаний в данном коде.

1. Мы сначала назвали функцию, потом написали "черный ящик", а только потом вызвали ее. (соблюдайте только этот порядок)
2. Если бы мы функцию не стали вызывать и нажали бы кнопку `source` (выполнение всего кода), то кусок кода с функцией бы никак не отобразился.
3. Инструкция `return` может встречаться в произвольном месте функции, ее исполнение завершает работу функции и возвращает указанное значение в место вызова. По сути, это что-то вроде `print()` и `break` одновременно. В `return` мы указываем переменную, которая в итоге должна появиться на выходе. 

## Принцип работы функции `sum()`

Функция `sum()` уже встроена в _R_, однако мы все же напишем свою, чтобы посмотреть, как она работает.

```{r}
SUM <- function(x){
  s <- 0
  for(i in 1:length(x)){
    s <- s + x[i]
  }
  return(s)
}

SUM(c(1,4,10,2))
SUM(c(0,0,0,0))
SUM(c(-1,1,2))

```

## Глобальные и локальные переменные

Переменные, которые вы задаете за пределами функции называются **глобальными**. В _RStudio_ они отображаются в правом верхнем углу. Если же вы инициализируете переменную внутри функции (например, переменная `s` внутри функции `SUM`), то такие переменные называются **локальными**. Если мы попробуем вывести локальную переменную за пределами функции, мы получим ошибку.

Если переменная задана за функцией, то есть она глобальная, ее все равно можно использовать в функции. Например вот так:

```{r}
a <-  0
f <- function(){
  return(a)
}
f()

```

Интересным получается результат, если мы используем локальную переменную с таким же названием, как и глобальная. 

```{r}
a <- 0
f <- function(){
  a <- 1
  return(a)
}
f()
```

Видим, что функция учла ту переменную, которая была локальной, проигнорировав глобальную.

Также можно внутри функции задать глобальную переменную знаком `<<-`, но так лучше никогда не делать. 

## Переменные по умолчанию

Функция необязательно может принимать только один аргумент, например, функция `matrix` принимает несколько аргументов (все их можно посмотреть, вызвав `help(matrix)`). Некоторые из этих аргументов уже чему-то равны по умолчанию. Это сделано, чтобы не вводить какие-то значения для них постоянно. Обычно это аргументы, которые могут принимать небольшое число значений (например, TRUE или FALSE). Так, например, в функции `matrix` есть аргумент `byrow`, который по умолчанию стоит в значении `FALSE` и означает, что элементы заполняются в матрице по столбцам. 

Создавая свои функции, мы тоже можем указывать подобного рода аргументы. 

Рассмотрим следующую задачу. Пусть у нас есть какой-то числовой вектор, и нам надо в каких-то случаях вывести максимальное число в этом векторе, а в каких-то случаях минимальное. Мы можем сделать это следующим образом. 

```{r}
max_or_min <- function(x, type = 'max'){
  if(type == 'max'){
    k <- max(x)
  } else {
    k <- min(x)
  }
  return(k)
}

max_or_min(c(1,10,2,4,100))
max_or_min(c(1,10,2,4,100), type = 'min')
```

По умолчанию наша функция находит максимальный элемент, но изменив параметр `type= 'min'`, мы можем найти минимальный элемент.

## Рекурсия

Рекурсивная функция это та функция, которая вызывает **саму себя**. На этом моменте мозг неопытного студента может сломаться. Попробуем же это более подробно разобрать на примере факториала. 

Хорошо известно, что $0!=1$, $1!=1$. А как вычислить величину $n!$ для большого $n$? Если бы мы могли вычислить величину $(n-1)!$, то тогда мы легко вычислим $n!$, поскольку $n!=n⋅(n-1)!$. Но как вычислить $(n-1)!$? Если бы мы вычислили $(n-2)!$, то мы сможем вычисли и $(n-1)!=(n-1)⋅(n-2)!$. А как вычислить $(n-2)!$? Если бы... В конце концов, мы дойдем до величины $0!$, которая равна $1$. Таким образом, для вычисления факториала мы можем использовать значение факториала для меньшего числа. 

```{r}
fact1 <- function(n){
  if(n == 0){
    return(1)
  } else {
    k <- fact1(n-1)
    return(n * k)
  }
}

fact1(0)
fact1(1)
fact1(2)
fact1(3)
fact1(5)
```




