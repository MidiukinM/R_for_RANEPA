---
title: "Управляющие конструкции"
output:
  html_document:
    highlight: pygments
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Итак, немного разобравшись с типами данных, приступим к более интересным и сложным вещам. Здесь мы рассмотрим 3 наиболее часто употребляемых управляющих конструкций, с помощью которых вы будете решать практически все задачи в этом семестре. Этот материал считается очень важным для понимания программирования в целом и его ни в коем случае нельзя разбирать поверхностно. Можно сказать, что он является фундаментом для всех алгоритмов, задач и функций, поэтому просьба быть чуточку внимательнее.

## Оператор if

Оператор `if` позволяет добавлять в вашу функцию **условие**. Если переменная, передаваемая оператору, удовлетворяет этому условию, то код идет по одной ветке, а если нет, то по другой. Более наглядно:

<h5 align = 'center'>
**if (** _условие_ **) {**
  
  _Действия, если TRUE_

**} else {**
  
  _Действия, если FALSE_

**}**
</h5>

**Рассмотрим простую задачу:** Студент Миша нетерпеливо ждет посвят, считая каждый день. Пусть 1 сентября оставалось 30 дней до события. Вы знаете сегодняшее число, давайте узнаем, дождался ли Миша посвят.

```{r}
# задаем переменную, которая будет обозначать день месяца
day <- 9
# строим условный оператор
if(day == 31){
  print('Дождался')
} else {
  print('Сегодня посвята нет :(')
}
``` 

Иногда условия не 2, а 3. В таком случае бывает удобно воспользоваться конструкцией `ifelse` либо 2 раза прописать `if`

**Задача 2:** Дано три числа. Вывести на экран наибольшее из них. 

```{r}
a <- 1
b <- -1
c <- 4

if(a > b & a > c){
  print(a)
} else {
  if(b > a & b > c){
    print(b)
  } else {
    print(c)
  }
}
``` 

## Цикл for

Циклы позволяют повторять какое-то действие некоторое кол-во раз. Пусть, например, нам нужно было бы вывести все числа массива. Как бы мы это могли сделать? Ну, например, так:

```{r}
vec <- c(10, 2, 35, 4)
print(vec[1])
print(vec[2])
print(vec[3])
print(vec[4])
```

Не очень удобно. Нам приходится создавать кучу лишних кликов и занимать больше места. Попробуем теперь сделать тоже самое с помощью цикла `for`:

```{r}
for(i in vec){
  print(i)
}

```

А теперь в общем виде.
<h5 align = 'center'>
**for (** _переменная, которая будет с каждым разом меняться (пробегать по циклу)_ **in** _последовательность значений, которые будет принимать переменная_**) {**

  _тело цикла_
  
**}**</h5>

Чтобы запомнить весь синтаксис, читайте каждый раз данный цикл таким образом:

<h5 align = 'center'>
**Для (** _каждой переменной_ **в** _последовательности_ **) выполнить {**

  _что-то выполняем_
  
**} **</h5>

**Задача:** Даны два целых числа A и B (при этом A ≤ B). Выведите все числа от A до B включительно.


```{r}
A <- -5
B <- -1
for(i in A:B){
  print(i)
}
```

**Задача:** По данному натуральному n вычислите сумму $1^3 + 2^3 + 3^3 + … + n^3$

```{r}
n <- 2
summa <- 0
for(i in 1:n){
  summa <- summa + i^3
}
print(summa)
```

Иногда полезно использовать `for` вместе с `if`. Посмотрим, когда это может быть полезно. 

**Задача:** По данному натуральному n вычислите значение n!. Сделайте это с помощью цикла. Помним, что $0!=1$

```{r}
otv <- 1
n <- 1
if(n == 0){
  print(1)
  for(i in 1:n){
    otv <- otv * i
  }
}
print(otv)
```

## Цикл while

Если цикл `for` позволяет повторять операцию **для** определенного конечного набора значений, то `while` повторяет операции, **пока** наша переменная удовлетворяет какому-то условию.

<h5 align = 'center'>
**while (** _переменная c условием_ **) {**

  _тело цикла_
  
**}**</h5>

Вспомним нашу задачку с посвятом, только немного изменим условие. Миша также ждет с нетерпением посвят. Он каждый день приходит домой и зачеркивает дни в календаре. Нам нужно написать код, который будет выводить число месяца и сообщение о том, что мы должны зачеркнуть день в календаре, пока посвят не настанет. Помним, что посвят 31 сентября. 

```{r}
day <- 9
while(day != 31){
  print(day)
  print('Зачеркиваем день')
  day <- day + 1
}
```

Последняя строка в цикле очень важна. Здесь переменная `day` выступает в качестве **счетчика**. Можно сказать, что она считает количество раз повторяющегося действия в цикле. Заметим, что эта переменная также "сидит" в условии цикла. Все это не дает циклу попасть в "бесконечную петлю", выполняя действие неограниченное кол-во раз. Например, в нашем случае, если бы мы не изменяли в конце цикла каждый раз нашу переменную, она бы всегда равнялась 9 и никогда бы не достигла числа 31, поэтому цикл повторял действие бесконечное число раз и наш код просто бы сломался. 

## break and next

На примере цикла `while` мы с вами отметили, что иногда циклы могут зацикливаться (тавтология, да). Чтобы этого избежать, можно также использовать оператор `break`. Он используется внутри циклов (for, while), чтобы остановить итерации в цикле и продолжить код уже за его пределами. Приведем пример в цикле `for`.

```{r}
vec <- c(1,2,3,4,5)
for( i in vec ){
  if(i == 3){
    break
  }
  print(i)
}
```

Следующий же оператор `next` полезен, когда мы хотим пропустить текущую итерацию цикла, не завершая его. 

```{r}
vec <- c(1,2,3,4,5)
for( i in vec ){
  if(i == 3){
   next
  }
  print(i)
}
```


