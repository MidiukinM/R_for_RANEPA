---
title: "Структуры данных"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
    highlight: pygments
  # df_print: paged
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Массивы или векторы

### Определение и способы задания

Массив - это основной тип данных, который представляет собой набор последовательных значений. Следует знать, что массив может содержать переменные только одного типа, иначе переменные будут принудительно изменены. Наиболее часто употребляемая функция для создания массива - это функция `c`. 

```{r collapse=TRUE}
(numbers <- c(1,4,5,2))
(names <- c('R', 'Ranepa', 'Rammstein'))
(logs <- c(TRUE, FALSE, 1, 0)) # логические и числовые типы переменных дружат :3
```

Создадим более сложные последовательности с помощью встроенных функций в _R_.

```{r collapse=TRUE}
seq(1,5, by=0.25)
seq(1,2, length.out=5)
rep(1:3, times=3)
rep(1:3, each=4)
```

### Индексирование 

Вектор это индексируемый вид данных. Это означает, что к каждому элементу в нем можно обратиться с помощью индекса. 

```{r}
n1 <- numbers[1]
n2 <- numbers[2]
n3 <- numbers[3]

print(n1)
print(n2)
print(n3)

numbers[c(1,2,3)]
```

Элементы вектора можно изменять.

```{r}
numbers[1] <- 10
numbers[2] <- 11
numbers[3] <- 12

print(numbers)
```

Есть также так называемая логическая индексация. Например выведем все четные значения в x.

```{r}
x <- c(10,3,5,8,1)
x[x %% 2 == 0]
```

### Полезные функции

Теперь рассмотрим несколько наиболее часто встречающихся функций с массивами. Функция `length(x)`, где `x` - это сам вектор, считает количество элементов в нем.

```{r}
vec <- c(0,0,0,0,0,0)
len <- length(vec)
print(len)
```

Элементов получилось 6,но что будет если мы попробуем вывести 7-ой элемент.

```{r}
print(vec[7])
```

А что, если мы захотим добавить еще элементы? Сделать это можно несколькими способами. Первый - создать новый вектор, в который будет входить предыдущий

```{r}
vec2 <- c(vec,10,13,99)
print(vec2)
```

В данном случае мы можем вставить элементы в начало или конец. Если же нужно вставить элемент в определенное место, используем функцию `append`.

```{r}
(numbers <- append(numbers,-Inf,after = 3))
```

Добавлять научились, теперь научимся удалять. 

```{r}
numbers <- numbers[-1]
print(numbers)
```

Также часто нам пригодится создавать вектор из случайных чисел. Более подробно это рассматривается при изучении математической статистики на 2 курсе, и вы скорее всего будете много работать со случайными числами на допе у Филиппа. Сейчас же мы просто ограничимся одной функцией. 

```{r}
random <- sample(x = 1:10, size = 5, replace = TRUE)
```

### Арифметические операции

Большинство арифметических операций векторизовано. Это означает, что функция применяется поэлементно. 

```{r}
vec1 <- c(1,2,3,4)
vec2 <- c(3,2,1,0)
vec1+vec2
sqrt(vec1)
```

А вот функция `sum()` невекторизована, она выдает одно число, состоящее из суммы всех остальных.

```{r}
sum(vec1)
```

Что, если мы попробуем сложить 2 вектора разной длины? 

```{r}
1:10 + 1:2
```

В подобных случаях _R_ зацикливает, то есть многократно повторяет короткий вектор до достижения длины более длинного вектора. Часто на этом моменте возникают ошибки в коде, поэтому если необходимо использовать зацикливание, то это следует указать явно с помощью функции `rep()` 

```{r}
rep(1:2, 2)
```

## Матрицы 

### Способы задания

Матрица представляет собой двумерный массив данных. По сути, это несколько векторов, которые уложены по столбцам. Создать матрицу можно с помощью функции `matrix`. Сначала нужно передать в эту функцию вектор, который состоит из значений внутри матрицы, а потом задать способы ее заполнения. Например, явно указать кол-во столбцов и строк.

```{r}
matrix(1:4, nrow = 2, ncol = 2)
```

Конечно, необязательно указывать и строки и столбцы. Достаточно указать что-то одно, а другое заполнится автоматически исходя из длины предоставленного в матрицу вектора.

```{r}
matrix(1:4, nrow = 2)
```

Если мы хотим, чтобы вектор был упакован не по столбцам, а по строкам, можно воспользоваться аргументом `byrow = TRUE`

```{r}
matrix(1:4, nrow = 2, byrow = TRUE)
```

Если же нам нужна матрица какого-то определенного размера, а мы укажем вектор короче этого размера, то значения просто продублируются. Но лучше так не делать, потому что можно запутаться. Если нужно продублировать в каком-то месте значения, укажите это явно в переданном массиве. 

```{r}
matrix(1:3, nrow = 2, ncol = 3, byrow = TRUE)
```

У матрицы есть атрибут `dim`, который отвечает за ее размерность. То есть он выдает кол-во строк и столбцов в матрице. 

```{r}
m <- matrix(1:6, nrow = 3)
dim(m)
```

### Арифметичекие операции

С матрицами работают те же правила, что и с векторами. То есть большинство операций происходит поэлементно. 

```{r}
(m1 <- matrix(1:4, nrow = 2))
(m2 <- matrix(c(10,20,30,40), nrow = 2))
m1 + m2
m2 - m1
m1 * m2
```

Заметим, что умножение символом `*` перемножит значения **поэлементно**. Помним, что в линейной алгебре матрицы перемножаются другим правилом. Чтобы перемножить по правилам линейной алгебры, нужно воспользоваться символом `%*%`

```{r}
m1 %*% m2
```

### Индексирование матриц

Так как матрица - это **двумерный** массив, то и индексирование производится с учетом двух размерностей. 

```{r}
(m <- matrix(1:6, ncol = 3))
m[1,3] # выводим элемент в первой строке и в третьем столбце
m[2,] # выводим все элементы во второй строке
m[,1] # выводим все элементы в первом столбце
```

Заметим, что когда мы выводим один столбец, у нас теряется размерность. То есть числа, которые сидят в выводимом столбце матрицы, имеют вид массива, а не матрицы. Чтобы этого не произошло, нужно в индексировании добавить аргумент `drop = FALSE`

```{r}
m[,1, drop = FALSE]
```

### Присоединение матриц

Две и более матриц можно соединить друг с другом. Это делается с помощью функций `cbind` и `rbind`. Первая присоединяет по строкам, вторая, соответственно, по столбцам. 

```{r}
rbind(m1,m2)
cbind(m1,m2)
```

## Список

### Способ задания

Список - это индексированная структура, элементами в котором могут быть объекты любого типа. Создание списков осуществляется функцией `list`

```{r}
list(1:4, 'R_for_RANEPA', matrix(c(1,2,3), nrow = 2, ncol = 3, byrow = TRUE))
```

Также каждую группу элементов в списке можно называть.

```{r}
(l <- list(vector = 1:4, stroka = 'R_for_RANEPA', matrix = matrix(0,2,2)))
```

### Индексирование

Индексирование в списках "двумерное". То есть, если мы воспользуемся обычным индексированием [ ], то мы получим доступ к подсписку. 
```{r}
l[1]
l['vector']
```

Если же мы воспользуемся индексированием с помощью [ [ ] ], то получим доступ к элементу подсписка. 

```{r}
l[[1]] # здесь получаем доступ к массиву
```

Когда мы получили доступ к нужному нам элементу, мы можем воспользоваться индексированием на нем. Предположим, что нам нужно вывести 3ий элемент в массиве, а массив находится в 1ом подсписке. 

```{r}
l[[1]][3]
```






