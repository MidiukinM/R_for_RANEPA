---
title: 'Циклы в одну строку. Семейка apply'
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
    highlight: pygments
  # df_print: paged
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Мы уже изучили с вами циклы for и while, однако в R есть еще один очень мощный инструмент (Loop Functions), который позволяет максимально компактно и быстро применять цикл в связке с какой-либо функцией к типам данных (массивам, спискам, матрицам и т.д.). В названии всех этих конструкций, как правило, содержится apply, и вот некоторые из них:

1. `lapply` (list apply) 
2. `sapply` (simplify apply)  
3. `vapply` (value apply)
4. `apply`
5. `tapply` (table apply)

Я рекомендую вам подробнее ознакомиться с первыми тремя функциями (lapply, sapply, vapply), так как они чаще всего используются, но также полезно знать и остальные. 

### `lapply`

lapply позволяет циклично применить какую-либо функцию к списку данных. То есть, например, предположим, что у нас есть список, состоящий из двух элементов (двух массивов a и b). 

```{r collapse=TRUE}
lst <- list(a = 1:5, b = 10:20)
print(lst)
``` 

Теперь предположим, что мы хотим найти сумму элементов в массиве a и b. Как нам уже известно, мы могли бы применить цикл for:

```{r collapse=TRUE}
for (i in lst){
  print(sum(i))
}
``` 

Однако для такой простой задачи мы все равно занимаем 3!! строки кода, да еще и в скобках можем запутаться. Поэтому проще это сделать с помощью `lapply`, которая займет всего одну строку кода, ведь как правило **хорошие программисты - это ленивые программисты**. Первым аргументов идет наш список, а вторым - функция, которую мы хотим примениить:

```{r collapse=TRUE}
otvet <- lapply(lst, sum)
print(otvet)
``` 

Расскажу о более неочевидном примере того, как можно применить "несуществующую" функцию внутри lapply. 

Предположим, у нас есть список из двух матриц a и b.

```{r collapse=TRUE}
lst2 <- list(a = matrix(1:6, nrow=2), b = matrix(1:10, nrow=5))
print(lst2)
``` 

Мы хотим вытащить 1ый столбец у каждой такой матрицы. Как правило, нет такой явной функции, которая помогла бы нам сделать это, но мы знакомы с индексированием! Но индексирование нельзя прописать как функцию для любой матрицы, что же делать? Решается это следующим образом:

```{r collapse=TRUE}
otvet2 <- lapply(lst2, function(my_arg) my_arg[,1])
print(otvet2)
```

Давайте немного прокомментируем, что мы сделали. Мы с вами написали функцию, которая принимает аргумент my_arg, а затем выводит (ретернит / то, что находится внутри return) 1 столбец от нашего my_arg. Когда мы прописываем подобное в lapply, вместо my_arg подставляются аргументы из нашего списка lst2. 

Заметим, что написанная нами таким образом функция, может существовать только внутри lapply, и мы не можем потом к ней обратиться за пределами этой строчки. Еще такая функция называется **анонимной**.

### `sapply`

sapply это модифицированная версия lapply, которая позволяет вывести ответ в более упрощенном виде. То есть, как мы видели до этого, результат lapply является список:

```{r collapse=TRUE}
otvet <- lapply(lst, sum)
print(otvet)
``` 

Результатом же sapply будет служить удобный именованный массив:

```{r collapse=TRUE}
otvet <- sapply(lst, sum)
print(otvet)
``` 

### `vapply`
 
Проблема sapply заключается в том, что она сама выбирает исходный тип, в котором выдаст нам ответ. Использование vapply позволяет нам выбирать тип, который мы хотим получить на выходе. Это добавляется третим аргументом.

Предположим, мы хотим вывести проверить каждый элемент внутри массива на то, больше ли он y=5? Используем для этого sapply и получим результат в логическом выражении.

```{r collapse=TRUE}
otvet2 <- sapply(1:10, function(x,y) x > y, y = 5)
print(otvet2)
``` 

Однако используя vapply, мы можем сами выбрать формат (например, числовой).

```{r collapse=TRUE}
otvet2 <- vapply(1:10, function(x,y) x > y, y = 5, numeric(1))
print(otvet2)
``` 

### `apply`

`apply`, как правило, позволяет удобно работать с матрицами (а матрицы - это наиболее часто встречаемый тип данных в работе с данынми)

Так, например, мы можем найти среднее по столбцам, либо по строкам в матрице a:

```{r collapse=TRUE}
a <- matrix(1:10, nrow=5)
print(a)
``` 

```{r collapse=TRUE}
otvet3 <- apply(a, 1, mean)
otvet4 <- apply(a, 2, mean)

print(otvet3)
print(otvet4)
``` 

В данном случае цифры 1 и 2 означают размерность матрицы, к которой мы образщаемся (1 - строки, 2 - столбцы). 

_Дополнительный пример для знающих статистику:_

Таким образом мы можем найти 25% и 75% квантили по строкам матрицы. 

Квантиль - это число, такое что заданная случайная величина не превышает его лишь с фиксированной вероятностью. Например, 0,25 - квантиль – число, ниже которого лежит примерно 25% выборки.

```{r collapse=TRUE}
(apply(a, 1, quantile, prob=c(0.25, 0.75)))
``` 

### `tapply`

tapply позволяет применить функцию не ко всем элементам вектора, а к отдельным группам внутри вектора. Предположим, например, что первые 10 наблюдений относятся к 1ой группе, а другие 10 ко 2ой. Тогда среднее в каждой из этих групп можно посчитать следующим образом:

```{r collapse=TRUE}
# задаем массив
x <- c(1:10, 11:20)
print(x)

# задаем группы с помощью функции gl 
# 2 группы, по 10 элементов в каждой
f <- gl(2, 10)

# применяем tapply
(tapply(x, f, mean))
``` 


