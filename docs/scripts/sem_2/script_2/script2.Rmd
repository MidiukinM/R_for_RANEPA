---
title: 'Изучаем пакет dplyr на примере nycflights13'
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
    highlight: pygments
  # df_print: paged
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Пакет dplyr является одним из важнейших атрибутов при анализе данных. Он включает в себя 6 основных функций, которые используются чаще всего. Это функции:

* `filter()` $-$ фильтрация строк по какому-либо условию, наложенному на параметр;
* `arrange()` $-$ сортировка строк;
* `select()` $-$ отображение нужных нам колонок;
* `group_by()` $-$ создание специальных групп для дальнейшего агрегирования;
* `summarize()` $-$ применение агрегирующей функции;
* `mutate()` $-$ видоизменение колонки.


### Пример задачи:

Для начала нужно установить пакеты dplyr и nycflights13 (Tools -> Install Packages -> ...), а потом загрузить их в наше окружение для работы. Делаем это так:

```{r collapse=TRUE}
# эти строчки запускать в каждом скрипте, в котором нужны данные пакеты

library(dplyr)
library(nycflights13)
``` 

Есть набор данных nycflights, содержащий все авиарейсы из аэропорта нью-йорк за 2013 год. Более подробное описание переменных представлено ниже:

* `year` $-$ год вылета;
* `month` $-$ месяц вылета;
* `day` $-$ день вылета;
* `dep_time` $-$ **фактическое** время вылета;
* `sched_dep_time` $-$ время вылета **по расписанию**;
* `dep_delay` $-$ задержка вылета (dep_time - sched_dep_time);
* `arr_time` $-$ **фактическое** время прилета;
* `sched_arr_time` $-$ время прилета **по расписанию**;
* `arr_delay` $-$ задержка прилета (arr_time - sched_arr_time);
* `carrier` $-$ сокращенное название авиакомпании;
* `flight` $-$ номер рейса;
* `tailnum` $-$ номер самолета;
* `origin` $-$ сокращенное название аэропорта **отбытия**;
* `dest` $-$ сокращенное название аэропорта **прибытия**;
* `air_time` $-$ общее время в полете;
* `distance` $-$ расстояние между аэропортами отбытия и прибытия, в милях;
* `hour` $-$ час вылета;
* `minute` $-$ минута вылета;
* `time_hour`$-$ полная дата в формате datetime.


Итак, перед нами стоит **ЗАДАЧА:** Найти авиакомпании, отправление рейсов которых в 2013 году в аэропорт SFO (San Francisco) задерживались сильнее остальных. Так мы можем понять, какой авиакомпанией лучше всего не стоило летать в Сан-Франциско, если вы не хотели просидеть какое-то количество времени в аэропорту в ожидании вашего рейса.  


**Замечание:** В данной задачи нужно учитывать другие очень важные параметры перед тем, как делать выводы. Например, сбалансированность выборки (какие-то компании совершают намного больше перелетов в год, чем другие, поэтому их общее время задержки может оказаться больше, но это не значит, что они хуже) и другие параметры. Пока что мы оставляем это вне рассмотрения нашей задачи. 


**РЕШЕНИЕ:**

Для начала подгрузим наш датасет flights в переменную df. С помощью хорошей функции `glimpse()` мы можем посмотреть на небольшое описание нашего датасета: можем посмотреть на количество наблюдений (кол-во строк), на кол-во параметров (кол-во столбцов), на типы переменных в каждом столбце (int, dbl, chr, ...) и т.д.

```{r collapse=TRUE}
df <- flights
glimpse(df)
``` 

Теперь отберем только те строки, которые соответствуют аэропорту SFO. Используем функцию `filter()`. В нее первым аргументом передаем наши данные, а затем условие, накладываюшее фильтр. 

```{r collapse=TRUE}
df2 <- filter(df, dest == 'SFO')

# смотрим на первые 5 строк в получившейся таблице
head(df2)
``` 

Так как переменных очень много, следует вывести на экран только те колонки, которые нас будут интересовать. Нам интересно смотреть на сокращенное название авиакомпании (carrier), на аэропорт прилета (dest) и на задержку рейса (dep_delay). Все это делается с помощью функции `select()`. Синтаксис похожий на функцию `filter()`: опять передаем нужный нам датафрейм, а затем через запятую просто названия колонок внутри этого датафрейма.

```{r collapse=TRUE}
df3 <- select(df2, carrier, dest, dep_delay)

# смотрим на первые 5 строк в получившейся таблице
head(df3)
``` 

Итак, действительно, у нас отобрались только те строки, которые соответствуют аэропорту SFO. Теперь мы можем отсортировать наши значения опять же для наглядности. Пользуемся функцией `arrange()`

```{r collapse=TRUE}
df4 <- arrange(df3, dep_delay)

# смотрим на первые 5 строк в получившейся таблице
head(df4)
``` 

По умолчанию функция `arrange()` сортирует наши наблюдения по возрастанию, нам же нужно по убыванию, поэтому применим дополнительно функцию `desc()`

```{r collapse=TRUE}
df4 <- arrange(df3, desc(dep_delay))

# смотрим на первые 5 строк в получившейся таблице
head(df4)
``` 

Итак, видим, что с наиболее большой задержкой произошел рейс авиакомпании AA (American Airlines), однако это не значит, что это самая худшая в плане задержек авиакомпания, так как мы смотрим лишь на одно наблюдение, а нужно смотреть в совокупности. 

Чтобы посмотреть на ситуацию в целом, нам нужно объединить все наблюдения в рамках каждой авиакомпании. То есть нам нужно вытащить уникальные значения авиакомпаний из столбца carrier и для каждой авиакомпании просуммировать минуты задержки (переменная dep_delay). Все это делается с помощью связки двух функций из пакета dplyr: `group_by()` и `summarize()`. Внутри `summarize()` полезно называть получившуюся колонку. Мы назовем ее sum_dep_delay. 

```{r collapse=TRUE}
# сначала создаем объект group_by(), который хранит наши группы параметра carrier
gb <- group_by(df4, carrier)

# теперь применяем АГРЕГИРУЮЩУЮ функцию на наблюдения внутри КАЖДОЙ группы объекта group_by()
df5 <- summarize(gb, sum_dep_delay = sum(dep_delay))

# смотрим на первые 5 строк в получившейся таблице
head(df5)
``` 

Видим, что все значения у нас получились **NA** (подумайте почему, перед тем как читать дальше). 

Произошло это потому, что в наших наблюдениях были пропуски (то есть объекты **NA**), а как мы с вами уже знаем любая операция чисел вместе с объектом **NA** дает нам **NA** (5 + NA = NA, 5 / NA = NA и т.д.). Для того чтобы с этим бороться нужно игнорировать такие значения, делает это параметр `na.rm = TRUE` и он может использоваться практически в любой арифметической функции. Применим его:

```{r collapse=TRUE}
# теперь применяем АГРЕГИРУЮЩУЮ функцию на наблюдения внутри КАЖДОЙ группы 
# объекта group_by() вместе с na.rm = TRUE
df5 <- summarize(gb, sum_dep_delay = sum(dep_delay, na.rm = TRUE))

# смотрим на первые 5 строк в получившейся таблице
head(df5)
``` 

Теперь все отлично. Мы получили общее время задержки для каждой авиакомпании. 

**Замечание:** вместе с group_by() можно применять не только функцию `sum()`, но и любую другую АГРЕГИРУЮЩУЮ функцию. Например, `mean()` для вычисления среднего или `count()` для подсчета значений 

Напоследок, отсортируем наши значения еще раз в порядке убывания, чтобы получить наглядный результат. 

```{r collapse=TRUE}
df6 <- arrange(df5, desc(sum_dep_delay))

# смотрим на первые 5 строк в получившейся таблице
head(df6)
``` 

Итак, теперь вот мы уже с вами видим, что больше всего минут задержки рейсов было в 2013 году у авиакомпании UA (UNITED AIRLINES). 

**ВНИМАНИЕ: не было на семинаре** Теперь предположим, что мы бы хотели получить итоговое время не в минутах, а в часах. Здесь нам помогает функция `mutate()`, которая просто преобразовывает данные в каком-либо столбце. Чтобы получить часы, нам нужно обратиться к целочисленному делению, а чтобы получить оставшиеся минуты - к получению остатка от деления. Делаем это так:

```{r collapse=TRUE}
df7 <- mutate(df6, sum_dep_delay_hour = sum_dep_delay %/% 60, 
              sum_dep_delay_minute = sum_dep_delay %% 60)

# смотрим на первые 5 строк в получившейся таблице
head(df7)
``` 
### Подведение итогов. Pipeline кода. 

Мы с вами видели, что для предыдущей задачи мы использовали на каждом шаге новое присвоение, записывая полученный результат в новую переменную. Так делать не очень хорошо: во-первых, создавать столько переменных как-то глупо, во-вторых, хранить в памяти каждый результат в переменной тоже не очень, ну и в-третьих, такой код занимает уж слишком много места. 

Чтобы избежать этого, в _R_ есть специальный инструмент pipe, сокращенно от pipeline, что переводится как план: например, **pipeline сегодняшнего семинара это:**

1. Установить пакеты
2. Разобрать функции на примере задачи
3. Рассказать про pipeline

Так вот, pipe в _R_ это значок `%>%`, который как бы связывает предыдущий кусок кода с последующим. Давайте перепишем нам прошлый код с помощью инструмента pipe:

```{r collapse=TRUE}
df %>% 
  
  filter(dest == 'SFO') %>% 
  
  select(carrier, dest, dep_delay) %>% 
  
  arrange(desc(dep_delay)) %>% 
  
  group_by(carrier) %>%
  
  summarize(sum_dep_delay = sum(dep_delay, na.rm = TRUE)) %>%
  
  arrange(desc(sum_dep_delay)) %>%
  
  mutate(sum_dep_delay_hour = sum_dep_delay %/% 60, 
         sum_dep_delay_minute = sum_dep_delay %% 60)
``` 
 
Стоит отметить, что первым делом мы обратились к нашему датафрейму (df), а потом на него как бы "накидывали" наши функции, поэтому внутри функций писать переменную с нашими данными уже не нужно. 

### Задачка для отработки. Выжившие на титанике. 

В пакете `titanic` есть датасет **titanic_train**. Он содержит информацию о пассажирах на борту того самого судна. Вот описание переменных:

* `PassengerID` $-$ id пассажира (его уникальный номер);
* `Survived` $-$ выжил ли пассажир или нет (1 - выжил / 0 - нет);
* `Pclass` $-$ класс обслуживания пассажира (1/2/3);
* `Name` $-$ полное имя пассажира;
* `Sex` $-$ пол пассажира;
* `Age` $-$ возраст пассажира;
* `Sibsp` $-$ сколько братьев либо сестер имел пассажир на борту;
* `Parch` $-$ кол-во детей или родителей пассажира на борту;
* `Ticket` $-$ номер билета;
* `Fare` $-$ стоимость билета;
* `Cabin` $-$ название каюты, в которой плыл пассажир;
* `Embarked` $-$ сокращенное название пункта отправления (например, S - Southampton).

**Попробуйте ответить на вопросы:** 

1. Людей какого пола выжило больше? 
2. Какой средний возраст выжившего?
3. Людей какого класса обслуживания выжило больше?  
4. Людей какого пола в зависимости от класса обслуживания выжило больше?  
5. Подумайте, что бы вы сами хотели поисследовать на этих данных и на какой вопрос ответить.


